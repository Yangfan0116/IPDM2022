---
title: "Introduction to practical disease modeling: Exercise 1"
author: "Carsten Kirkeby"
output: 
   html_document:
      toc: true
      toc_float: true
params:
  solutions: TRUE
  latex: FALSE
header-includes:
  \usepackage{comment}
---

```{r setup, include=FALSE}
## This code along with the makefile allows us to show solutions conditional on file type
set.seed(2022-07-22)
solution_start <- function(){
	rv <- ""
	if(!params$solutions & !solution_current){
		if(params$latex) rv <- "\\begin{comment}" else rv <- "<!--"
		knitr::opts_chunk$set(eval = FALSE)
		solution_current <<- TRUE
	}
	return(rv)
}
solution_end <- function(){
	rv <- ""
	if(!params$solutions & solution_current){
		if(params$latex) rv <- "\\end{comment}" else rv <- "-->"
		knitr::opts_chunk$set(eval = TRUE)
		solution_current <<- FALSE
	}
	return(rv)
}
solution_current <- FALSE
```


Exercises with herd dynamics

***

# 1. Introducing herd dynamics


We start by constructing a simple simulation model for a dairy farm, and use an age counter (days) for the cows. 

Please look at the code and make sure you understand what each line does.

First we construct a herd with cows that age over time:

```{r}
set.seed(250)

n_cows <- 100

# Create the farm:
farm <- data.frame(id =1:n_cows,
                   age=round(runif(n_cows,730,1642)))

# We want to simulate 5 years:
end_time <- 5 * 365

# Collect the mean age of the cows in herd over time:
age_collect <- numeric(end_time)

for (t in seq_len(end_time))
{

   # Add one day to the age of all the animals, for each simulated:
   farm$age <- farm$age + 1

   # Save the daily mean age of all cows:
   age_collect[t] <- mean(farm$age)
}

```

We can then plot the age of the cows over time:

```{r}
plot(age_collect, type="l", lwd=2)
```

We see that the cows age over time as the mean age in the herd increases. However, this does not reflect a real herd. We want to model a cattle farm where the old cows are replaced with new cows over time. When the cows reach 1642 days, they will be replaced with a new cow that is two years old:


```{r}
set.seed(250)

n_cows <- 100

# Create the farm:
farm <- data.frame(id =1:n_cows,
                   age=round(runif(n_cows,730,1642)))

# We want to simulate 5 years:
end_time <- 5 * 365

# Collect the mean age of the cows in herd over time:
age_collect <- numeric(end_time)

for (t in seq_len(end_time))
{
   # If cows reach the age of 1642, they are replaced with a new cow that is 2 years old in DIM = 1:
   farm$age[farm$age>=1642] <- 730

   # Add one day to the age of all the animals, for each simulated:
   farm$age <- farm$age + 1

   # Save the daily mean age of all cows:
   age_collect[t] <- mean(farm$age)
}

```

We can then plot the age of the cows over time:

```{r}
plot(age_collect, type="l", lwd=2)
```

The mean age in the herd oscillates over time, as a natural cause of the dynamics in the herd when cows age and are replaced with new cows.

We can look at the variation in the age over time:

```{r}
quantile(age_collect)
```





# 2. Exercises

Hint: Modify the above code to solve the exercises.

## A.
What happens with the variation if you increase the number of cows to 500? And 5000?

## B.
Try to change the age before replacement up and down. What happens with the variation in the results? Look at the mean age of the cows over time. Can you identify a repeating pattern (periodicity) in the results? Where does that come from?

## C.
Now introduce dynamics in the replacement age: Make a new column with an individual replacement age for each cow (normal distribution with mean = 1642 and sd=50). When the cows reach their own predefined replacement age, then replace them. Remember that the new cows should have their own replacement age. What happens?
Look at the periodicity now. What happened?

## D.
What modification would you like to introduce to this model, to explore the dynamics in the herd?

## E.
Try to run the initial model twice with the same seed and compare results. Then change the seed and compare again. What happens?

***


# 3. Bonus exercise

If you have finished the exercises above, then consider the following bonus programming exercise (but don't worry if you don't have time to do this - it is optional!).

There are three approaches to computer programming:

1. Procedural programming. This is the standard way in which we tend to code disease models, as it is easiest to get used to for simple models, and is the approach used in the exercises above. However, it is not very expandable so is not necessarily a good approach for more complex models.

1. Functional programming. This lends itself very well to certain tasks such as data analysis using dplyr/tidyverse style code. However, it is not very well suited to writing disease models.

1. Object-oriented programming. This is a more modern style of programming that is used for most commercial programming applications. The central idea of object-oriented programming is that we encapsulate the implementation of a (potentially large and complex) system within an object so that the inner workings of this object are hidden. Higher-level usage of the object occurs via methods that are also defined within the object. The A big advantage of this approach is that changes can be made to the implementation of the object without breaking other parts of the code that use the object. This is particularly relevant when dealing with larger projects with multiple complex parts, but is also useful for smaller collaborative projects. A second advantage is that it becomes much easier to replace small parts of your R code with faster code written in C++ that has the same methods. The downside is that the code takes a little bit of getting used to, as the idea of an object with a persistent state is quite different to what we typically do with procedural programming.

The best way to illustrate this is with an example. The code below implements a "farm" object that encapsulates the same model as we had before.  We use the R6 package to set up an object that has a persistent state (i.e. remembers things about itself), accessor methods (so that we can interact with the system externally), and implementation methods that update the internal state.

```{r}
library("R6")

## Define the farm class:
Farm <- R6Class("Farm",

  # Private objects that we can only see within the class:
  private = list(
    
    # The number of cows:
    n_cows = 0L,
    
    # The data frame of cows:
    cows = data.frame(id = numeric(0),
                      age = numeric(0)),
    
    # The current time:
    time = 0L
    
  ),
                              
  # The public methods:
	public = list(

	  # An initialize method is mandatory:
		initialize = function(n_cows) {
		  
		  # Set the number of cows:
		  private$n_cows <- n_cows
		  
		  # Set the data frame of cows:
		  private$cows <- data.frame(id = 1:n_cows, 
		                          age = round(runif(n_cows,730,1642)))
		  
		  # Set the time:
		  private$time <- 1L
		  
		},

		# An update method for a single time step:
		update = function() {
		  
		  private$cows$age <- private$cows$age + 1L
  	  private$time <- private$time + 1L

		},

		# A method to get the current cows:
		get_cows = function() {
		  
		  return(private$cows)
		  
		},
		
		# A method to get the current average age:
		get_mean_age = function() {
		  
		  mean_age <- mean(private$cows$age)
		  return(mean_age)
		  
		}

	)
)
```

Running this code doesn't actually do anything other than define the class. To run it we need to instantiate an object of this class, then do things with it:

```{r}
# This calls the initialize method with the arguments supplied:
farm <- Farm$new(n_cows = 100L)

# Now we can call the other methods like so:
farm$get_cows()
farm$get_mean_age()

# To run it we do something similar to before except that the implementation is now hidden:

end_time <- 5 * 365
age_collect <- numeric(end_time)

for (t in seq_len(end_time)) {

   # Update the object:
   farm$update()

   # Save the daily mean age of all cows:
   age_collect[t] <- farm$get_mean_age()
}

plot(age_collect, type="l", lwd=2)
```

## Bonus question A:

Copy/paste the R6 model above, and add the same change to the replacement age as we did before.

`r solution_start()`
### Solution

We only need to change the update method - the rest of the code below is the same as before:

```{r}
library("R6")

## Define the farm class:
Farm <- R6Class("Farm",

  # Private objects that we can only see within the class:
  private = list(
    
    # The number of cows:
    n_cows = 0L,
    
    # The data frame of cows:
    cows = data.frame(id = numeric(0),
                      age = numeric(0)),
    
    # The current time:
    time = 0L
    
  ),
                              
  # The public methods:
	public = list(

	  # An initialize method is mandatory:
		initialize = function(n_cows) {
		  
		  # Set the number of cows:
		  private$n_cows <- n_cows
		  
		  # Set the data frame of cows:
		  private$cows <- data.frame(id = 1:n_cows, 
		                          age = round(runif(n_cows,730,1642)))
		  
		  # Set the time:
		  private$time <- 1L
		  
		},

		# An update method for a single time step:
		update = function() {
		  
		  # If cows reach the age of 1642, they are replaced with a new cow that is 2 years old in DIM = 1:
      private$cows$age[private$cows$age>=1642] <- 730

		  private$cows$age <- private$cows$age + 1L
  	  private$time <- private$time + 1L

		},

		# A method to get the current cows:
		get_cows = function() {
		  
		  return(private$cows)
		  
		},
		
		# A method to get the current average age:
		get_mean_age = function() {
		  
		  mean_age <- mean(private$cows$age)
		  return(mean_age)
		  
		}

	)
)
```
`r solution_end()`

## Bonus question B:

What changes do you need to make to the code that runs the model?

`r solution_start()`
### Solution
We don't need to make any changes to the code that runs the model - that is the point of encapsulation! This is identical to before:

```{r}
# Create and run the model as before:
farm <- Farm$new(n_cows = 100L)

# Run the model as before:

end_time <- 5 * 365
age_collect <- numeric(end_time)

for (t in seq_len(end_time)) {

   # Update the object:
   farm$update()

   # Save the daily mean age of all cows:
   age_collect[t] <- farm$get_mean_age()
}

plot(age_collect, type="l", lwd=2)
```
`r solution_end()`

## Bonus question C:

Are there any further modifications that you could make to avoid hard-coding the replacement age?

`r solution_start()`
### Solution

It might be a good idea to let the user change the replacement ages within the model. But we can still supply default values for the initialize method (sometimes called the "constructor") so that we don't break our existing code with this new functionality. While we're at it, let's add methods to potentially change the replacement age while running the model:

```{r}
library("R6")

## Define the farm class:
Farm <- R6Class("Farm",

  # Private objects that we can only see within the class:
  private = list(
    
    # The number of cows:
    n_cows = 0L,
    
    # The age of replacement heifers:
    age_heifer = 0L,
    
    # The age at which animals are replaced:
    age_replacement = 0L,
    
    # The data frame of cows:
    cows = data.frame(id = numeric(0),
                      age = numeric(0)),
    
    # The current time:
    time = 0L
    
  ),
                              
  # The public methods:
	public = list(

	  # An initialize method is mandatory:
		initialize = function(n_cows, age_heifer = 730, age_replacement = 1642) {
		  
		  # Set the number of cows:
		  private$n_cows <- n_cows
		  
		  # Store the ages using the public method we provide below:
		  self$set_replacement_ages(age_heifer = age_heifer, age_replacement = age_replacement)

		  # Set the data frame of cows:
		  private$cows <- data.frame(id = 1:n_cows, 
		                          age = round(runif(n_cows,age_heifer,age_replacement)))
		  
		  # Set the time:
		  private$time <- 1L
		  
		},

		# A set method for the replacement ages:
		set_replacement_ages = function(age_heifer = NULL, age_replacement = NULL) {
		  if(!is.null(age_heifer)) private$age_heifer <- age_heifer
		  if(!is.null(age_replacement)) private$age_replacement <- age_replacement
		},
		
		# An update method for a single time step:
		update = function() {
		  
		  # If cows reach the age of age_replacement, they are replaced with a new cow that is age_heifer days old:
      private$cows$age[private$cows$age>=private$age_replacement] <- private$age_heifer

		  private$cows$age <- private$cows$age + 1L
  	  private$time <- private$time + 1L

		},

		# A method to get the current cows:
		get_cows = function() {
		  
		  return(private$cows)
		  
		},
		
		# A method to get the current average age:
		get_mean_age = function() {
		  
		  mean_age <- mean(private$cows$age)
		  return(mean_age)
		  
		}

	)
)
```

The code to run this is exactly the same as before, except that we can now change the replacement age on e.g. year 3:

```{r}
# Create and run the model as before:
farm <- Farm$new(n_cows = 100L)

end_time <- 5 * 365
age_collect <- numeric(end_time)

for (t in seq_len(end_time)) {
  
   # But now we can change the replacement age for year 3 onwards:
   if (t == (3 * 365)) {
      farm$set_replacement_ages(age_replacement = 365*6)
   }

   # Update the object:
   farm$update()

   # Save the daily mean age of all cows:
   age_collect[t] <- farm$get_mean_age()
}

plot(age_collect, type="l", lwd=2)
```

`r solution_end()`

For more information on using R6 classes, see:  https://r6.r-lib.org/articles/Introduction.html
